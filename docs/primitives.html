<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><title>Fluxus manual v0.9</title><link rel="stylesheet" href="fluxusdoc.css"></head><body>
<hdr><a href="index.html">Fluxus manual</a> v0.9 : (C) 2005 Dave Griffiths : dave at pawfal dot org : <a href="http://www.pawfal.org">www.pawfal.org</a></hdr>

<h1>6.0  Primitives</h1>
Primitives are objects that you can render. There isn't really much else in a 
fluxus scene, except lights, a camera and lots of primitives.

<big>6.1  Retained Mode</big>
    
The normal way to create a primitive is to call it's build function and then 
use it's returned ID (either directly, or by grabbing) to modify it later. 

<c>(define myobj (build-cube))
(grab myobj)
(colour (vector 1 0 0))
(ungrab) ; always remember to ungrab...	</c>

Here are all the primitives:

<c>(build-cube)</c>
a simple cube, texture mapped placement per face

<img src="images/cube.jpg">

<c>(build-sphere hsegments rsegments)</c>
a sphere with the resolution specified in verts, texture mapped in normal 
"world map" style

<img src="images/sphere.jpg">

<c>(build-plane xsegments ysegments)</c>
a tesselated poly plane, texture mapped from 0->1 in both dimensions

<img src="images/plane.jpg">

<c>(build-cylinder hsegments rsegments)</c>
a capped cylinder, texture map wrapped around

<img src="images/cylinder.jpg">

<c>(build-text text)</c>
builds a sequence of planes, texture mapped so that a font texture can be used 
to display text. might also be useful for more abstract things. the texture 
map should be drawn as follows:

(ascii 32 onwards)
  ! " # $ % & ' ( ) * + ' - . / 
0 1 2 3 4 5 6 7 8 9 : ; < = > ?
@ A B C D E F G H I J K L M N O
P Q R S T U V W X Y Z [ \ ] ^ _
` a b c d e f g h i j k l m n o
p q r s t u v w x y z { | } ~

the font assumed to be non proportional - there is an example font shipped with 
fluxus

<img src="images/text.jpg">
ok, so this isn't a very good font texture :)

<c>(build-nurbs-sphere hsegments rsegments)</c>
builds a tesselated nurbs sphere, texture mapped in the same fashion as the poly
sphere
<img src="images/nurbs-sphere.jpg">
a nurbs patch sphere, with a control vertex tweaked to prove it's curvy nature

<c>(build-nurbs-plane usegments vsegments)</c>
builds a tesselated nurbs plane, texture mapped in uv direction
<img src="images/nurbs-plane.jpg">
a nurbs patch plane, again with a control vertex tweaked
		
<big>6.2  Primitive Data</big>

Each primitive is made up of arrays of data that describe it's shape and surface 
properties. The data is always stored per-vertex, and is created when you call 
the build function. You do not have to know anything about this data to use 
primitives, but it means you can modify or deform them in a more detailed way than
using functions we've already looked at, and some primitives are only useful if
pdata is used to control them.

So, for example <c>(build-sphere)</c> creates a polygonal object with a spherical 
distribution of vertex point data, surface normals at every vertex and texture 
coordinates, so you can wrap a texture around the primitive. This data 
(primitive data, or pdata for short) can be read and written to by your 
scripts, using the following commands (which operate on the currently grabbed 
object):

<c>(pdata-set name vertnumber vector)</c>
sets the data on the currently (grab)ed object to the input vector

<c>(pdata-get name vertnumber)</c>
returns the vector from the pdata on the currently (grab)ed object

<c>(pdata-size)</c>
returns the size of the pdata on the currently (grab)ed object (the number of 
verts)

The name describes the data we want to access, for instance "p" contains 
the vertex positions:

so, some examples to make sense of this:

<c>(pdata-set "p" 0 (vector 0 0 0))</c>

sets the first point in the primitive to the origin (not all that useful)

<c>(pdata-set "p" 0 (vadd (pdata-get "p" 0) (vector 1 0 0)))</c>

The same, but sets it to the original position + 1 in the x
offsetting the position is more useful as it constitutes a deformation of the 
original point.

(see <a href="deforming.html">deforming</a> for more info on deformations)

The pdata availible depends on the type of the primitive.

Polygonal based primitives (Cube, Sphere, Cylinder, Plane, Text)

Positions:      "p" vector
Normals:        "n" vector
Texture coords: "t" vector
Vertex colours: "c" colour

NURBS based primitives (NURBSSphere, NURBSPlane)

Positions:      "p" vector
Normals:        "n" vector
Texture coords: "t" vector

<big>6.2 Geometry requiring pdata access</big>

The following primtives are different to the previous types in that they require 
pdata modification to do anything useful. 
		
<c>(build-particles num)</c>
builds a particles primitive containing num points, all initially set to the 
origin. you use the pdata functions to edit the postions, colours and sizes. 
particles come in two flavors, camera facing sprites, which are the default, can 
be textured and individually scaled; and points (when <c>(hint-points)</c> is set),
which cannot be textured but are much faster to render, as they are hardware 
supported gl points. by default these point particles are square, turn on 
<c>(hint-anti-alias)</c> to make them circular.

<img src="images/sprites.jpg">
happy textured sprites

<img src="images/particles.jpg">
point particles

<b>Particle primitive pdata</b>

Positions:      "p" vector
Colours:        "c" colour
Sizes:          "s" vector

<c>(build-line numpoints)</c>
builds a line consisting of numpoint points. the geometry is constantly camera 
facing and is texture mapped so the texture is stretched along the line from start
to finish. you use the pdata functions to edit the postions and widths of the lines. 
if used lit, the normals are faked to approximate a circular cross section. 
additionally, if solid rendering is cleared with (hint-none) and (hint-wire) is 
activated, a faster constant width line will be drawn - width specified by the 
(line-width) command

<img src="images/line.jpg">

<b>Line primitive pdata</b>

Positions:      "p" vector
Width:          "w" float 

<c>(build-polygons size type)</c>
builds a raw polygon primitive with size vertices (everything set to zero). 
type is a number that refers to the way the vertices are interpreted to build
polygons, and can be one of the following:

0=TRISTRIP
1=QUADS
2=TRILIST
3=TRIFAN
4=POLYGON

<big>6.3 Topology and pdata</big>

The order and meaning of the vertex pdata depends on the exact primitive, and in 
the case of polygonal objects, the topology of the polygons.

So a polygon primitive built from triangle lists will have the following ordering
of it's pdata:

(This is a really bad way of describing something which is easier done with a 
picture, see your OpenGL manual, or search the net for "OpenGL Primitives" :)

pdata index 0 : face 0 vert 0
pdata index 1 : face 0 vert 1
pdata index 2 : face 0 vert 2
pdata index 3 : face 1 vert 0
pdata index 4 : face 1 vert 1
pdata index 5 : face 1 vert 2

Quad lists:

pdata index 0 : face 0 vert 0
pdata index 1 : face 0 vert 1
pdata index 2 : face 0 vert 2
pdata index 3 : face 0 vert 3
pdata index 4 : face 1 vert 0
pdata index 5 : face 1 vert 1

Triangle strip:

pdata index 0 : face 0 vert 0 
pdata index 1 : face 0 vert 1 & face 1 vert 0 
pdata index 2 : face 0 vert 2 & face 1 vert 1 & face 2 vert 0
pdata index 3 : face 1 vert 2 & face 2 vert 1 & face 3 vert 0 
pdata index 4 : face 2 vert 2 & face 3 vert 1 & face 4 vert 0
pdata index 5 : face 3 vert 2 & face 4 vert 1 & face 5 vert 0     

Triangle fan:

pdata index 0 : vert 0 for all faces
pdata index 1 : face 0 vert 1 
pdata index 2 : face 0 vert 2 & face 1 vert 1
pdata index 3 : face 1 vert 2 & face 2 vert 1
pdata index 4 : face 2 vert 2 & face 3 vert 1
pdata index 5 : face 3 vert 2 & face 4 vert 1

Polygon (the easy one):

pdata index 0 : vert 0
pdata index 1 : vert 1
pdata index 2 : vert 2
pdata index 3 : vert 3
pdata index 4 : vert 4
pdata index 5 : vert 5

This lookup is the same for all the pdata on a particular primitive - vert positions, 
normals, colours and texture coordinates.

Although this implicit topology means the primitive is optimised to be very quick to 
render, it costs some memory as points are duplicated. This is a standard tradeoff,
the most optimal poly topology are triangle strips, as the duplication gets less, 
depending on how long your strips get.

The topologies for the various polygon primitives are as follows:

cube: quad list
plane: quad list
text: quad list
sphere: triangle list
cylinder: triangle list

<b>Nurbs topology</b>

Nurbs pdata are much simpler to deal with, as the topology is just a patch grid for 
both spheres and subdivided planes. 

<big>6.4  Instancing</big>

Sometimes retained mode primitives can be unwieldy to deal with. For instance, 
if you are rendering thousands of identical objects, or doing things with 
recursive graphics, where you are calling the same primitive in lots of 
different states - keeping track of all the IDs would be annoying to say the 
least.

This is where instancing is helpful, all you call is:

<c>(draw-instance myobj)</c>

and it will redraw any given object in the current state (immediate mode).
An example:

<c>(define myobj (build-nurbs-sphere 8 10)) ; make a sphere

(define (render-spheres n)
	(push)
	(translate (vector n 0 0)) ; move in x
	(draw-instance myobj)       ; stamp down a copy
	(pop)
	(if (< n 0)
		0
		(render-spheres (- n 1)))) ; recurse!

(every-frame "(render-spheres 10)") ; draw 10 copies</c>

<big>6.5  Built In Immediate Mode Primitives</big>

To make life even easier than having to instance primitives, there are some 
built in primitives that can be rendered at any time, without being built:

<c>(draw-cube)
(draw-sphere)
(draw-plane)
(draw-cylinder)</c>

so the it makes the code above simpler:

<c>(define (render-spheres n)
	(push)
    (translate (vector n 0 0)) ; move in x
	(draw-sphere)              ; render a new sphere
	(pop)
	(if (< n 0)
		0
		(render-spheres (- n 1)))) ; recurse!

(every-frame "(render-spheres 10)") ; draw 10 copies</c>

These built in primitives are very restricted in that you can't edit them 
or change their resolution settings etc, but they are handy to use for quick 
scripts with simple shapes.

